{\rtf1\ansi\ansicpg1252\cocoartf2639
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red255\green255\blue255;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;\cssrgb\c100000\c100000\c99985;}
\margl1440\margr1440\vieww11780\viewh17140\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec3 //____________________________________\
// Intro\
/*\
\
1. A numerical representation of our code's performance\
\
2. Compares different algorithms effectivness\
\
3. It comes up on interviews\
\
BETTER?\
    Faster/speed, memory intensive, readibility, undersdanding\
\
\
*/\
\
//____________________________________\
// Example\
// add numbers from 1 - n\
\
// method 1\
\
function addUpTo(n) \{\
  //acumulator\
  let total = 0;\
  for (let i = 0; i <= n; i++) \{\
    total += i;\
  \}\
  return total;\
\}\
\
let t1 = performance.now();\
addUpTo(1000000000);\
let t2 = performance.now();\
console.log(`Time elapsed (1st method): $\{(t2 - t1) / 1000\} seconds`);\
// 0.9555900000333786 seconds\
\
// method 2\
\
function addUpTo2(n) \{\
  // mathematical equation that accumulates (whole explanation behind it)\
  return (n * (n + 1)) / 2;\
\}\
\
let t3 = performance.now();\
addUpTo2(1000000000);\
let t4 = performance.now();\
console.log(`Time elapsed (2nd method): $\{(t4 - t3) / 1000\} seconds`);\
// 0.000006958961486816406 seconds\
\
//____________________________________\
// The problem with time\
/*\
1. different machines (or even same machines) will return different times\
\
2. Super fast algorithms will not return precise time\
\
3. We wouldn't want to run different algorithms returning 10h, 6h, 20h, 1h and then find the difference\
*/\
\
//____________________________________\
// If not time, then what? Counting operations\
/*\
\
method 1\
function addUpTo(n) \{\
  let total = 0;\
  for (let i = 0; i <= n; i++) \{\
    total += i;\
  \}\
  return total;\
\}\
\
- Many operations\
    - Assigning/memory total, looping, assignin i, condition i<, or =, to n, then i+1, then total assing to, total(look at memory) + i(look at memory), i will = n = 1,2,3...9,999, 1,000,000,000\
- As input grows, so does the number of operations\
- Trend: as input grows, so does run time\
\
method 2\
function addUpTo2(n) \{\
  return (n * (n + 1)) / 2;\
\}\
\
- Always 3 operations: multiplication, sum+1, divide/2\
- As input grows, operations remain the same\
- Trend: as input grows, operations remain the same\
\
\
*/\
\
\
//____________________________________\
// Official intro to Big 0\
/*\
\
1. Big O notation is the relationships of an algorithm between the run time and its input value\
\
2. When input grows, how will performance change?\
    f(input)=input\
    f(input)=input(squared)\
    f(input)=1\
    or something else\
\
3. Big O is the worse case scenario, the upper bound of the input\
\
\
// method 1\
- Many operations\
- O(n) (number of operations will lead to a multiple of operations)\
\
// method 2\
- Always 3 operations\
- O(1) (as input grows, no change in operations)\
\
\
\
\
*/\
}